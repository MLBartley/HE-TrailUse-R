# Analysis of All Trails {#AllTrailsAnalysis}

```{r, eval = T, echo=FALSE, message=F, warning=F, include = F}

library(colorblindr)
library(cowplot)
library(dplyr)
library(forecast)
library(here)
library(gganimate)
library(ggplot2)
library(gratia)
library(itsadug)
library(lubridate)
library(magrittr)
library(marginaleffects)
library(mgcv)
library(transformr)
library(xtable)

source(here("scripts/01-LoadData.R"))
source(here("scripts/01.01-OrganizeSpatialData.R"))


##set colors for new plots 
colors <- palette(pals::polychrome(36))

names(colors) <- c(levels(as.factor(allData$trailname)), "Felix Canyon")
 
#fix light Bridger Foothils
colors[2] <- "#c0b9bd"

#helps to format this document 
#by default the included code chunks do not appear in the report view
knitr::opts_chunk$set(echo = F, 
                      eval = F,
                      message = F, 
                      # cache=TRUE, 
                      warning=FALSE, 
                      error=FALSE, 
                      root.dir = normalizePath(".."))

options(knitr.table.format = function() {
  if (knitr::is_latex_output()) 'latex' else 'pandoc'
})


```


```{r functions, eval = T}
## Model Checking function
tsDiagGamm <- function(x, timevar, observed, f = 0.3, type = "normalized") {
  resi <- resid(x$lme, type = type)
  fits <- exp(fitted(x$lme))
  on.exit(layout(1))
  layout(matrix(1:6, ncol = 3, byrow = TRUE))
  plot(resi ~ fits, ylab = "Normalized Residuals",
       xlab = "Fitted Values", main = "Fitted vs. Residuals")
  lines(lowess(x = fits, y = resi, f = f), col = "blue",
        lwd = 2)
  plot(resi ~ timevar, ylab = "Normalized Residuals",
       xlab = "Time", main = "Time series of residuals")
  lines(lowess(x = timevar, y = resi, f = f), col = "blue", lwd = 2)
  plot(observed ~ fits, ylab = "Observed",
       xlab = "Fitted Values", main = "Fitted vs. Observed",
       type = "n")
  abline(a = 0, b = 1, col = "red")
  points(observed ~ fits)
  lines(lowess(x = fits, y = observed, f = f), col = "blue",
        lwd = 2)
  hist(resi, freq = FALSE, xlab = "Normalized Residuals")
  qqnorm(resi)
  qqline(resi)
  acf(resi, main = "ACF of Residuals")
}

#This function calculates the deviance of out-of-sample data,
#conditional on their mean predicted value from the model
get_deviance <- function(model, y_pred, y_obs, weights = NULL){
  stopifnot(length(y_obs)==length(y_pred))
  #We don't use the weights term in this paper, but it can be useful if
  #how well the model matters more for some sample points than others
  if(is.null(weights)) weights = rep(1, times= length(y_obs))
  #this uses the deviance residual function from the model family to
  #calculate deviances for individual points
  dev_residuals = model$family$dev.resids(y_obs, y_pred, weights)
  return(sum(dev_residuals))
}
```

<!-- ## Application to All Camera-Monitered Bridger Trails -->

## Data Used

This joint analysis covers the following Bridger Mountain subtrails:

1.  Fairy Creek
2.  College M
3.  Bridger Ridge (combination of Bridger, Baldy to Bridger, Bridger to Ross Pass, M to Baldy, Ross Pass to Sacagawea Peak)
4.  Steep Way
5.  Sacagawea Pass
6.  Carroll Creek
7.  Raptor View
8.  Sypes Canyon
9.  College M to Sypes
10. Truman Gulch
11. East Bridger South
12. East Bridger North
13. Lower Shafthouse
14. Corbly Gulch
15. North Cottonwood to Johnson Canyon
16. North Cottonwood Access
17. Ross Pass
18. Middle Cottonwood
19. Johnson Canyon Jeep Trail
20. Benchmark Road
21. Horsethief Mountain

```{r, eval = T}
# allTrail$subsectionF<- factor(allTrail$subsectionname, order = F)
# allTrail$trailnameF <- factor(allTrail$trailname, order = F)

sub.number <- length(unique(allTrail$subsectionF))

#uncomment depending on whether you want all models to run (will take several hours)
# runall = T
runall = F

```

## Fitting a Generalized Additive Mixture Model

Here, we extend the Generalized Additive (Mixture) Model we first explained in Section \@ref(Models) and then examined through application to Middle Cottonwood trail in Section \@ref(MidCot) to now include all Bridger trails with counter camera data. This extension now includes different grouping levels (trail subsections) that require modeling of nonlinear functional relationships between covariates and outcomes where the shape of the function itself varies between different grouping levels. Hierarchical GA(M)Ms provide a natural extension to the standard GAM framework that allows smooth functional relationships between predictor and response to vary between groups, but in such a way that the different functions are in some sense pooled toward a common shape.

All models are fit in R. HGAMs are fit with the **mgcv** package [@R-Wood1, @R-Wood2, @R-Wood3, @R-Wood4, @R-Wood5].

In our application, where we want to estimate and predict trail use at trails in the Bridger Mountains, we may assume that each trail will have its own response function (e.g. melting snowpack may take longer at higher elevation and thus trail use would be concentrated on trails that clear sooner), but since the trails are all in the same range we can also expect similar responses over the year. Estimating a separate function for each trail (or subsection) throws away a lot of shared information and could result in highly noisy function estimates if there were only a few data points for some trails. Conversely, estimating a single average relationship could result in a function that does not predict any specific group well. We aimed for a hierarchical model that includes a global curve plus trail subsection-specific curves that were penalized to be close to the mean function.

Sometimes this dependence can be capture using the fixed and random effects in a GAMM, however when modelling all trails in this dataset we observed remaining temporal dependence (not shown, but see the ACF and PACF graph explanations in Section \@ref(ACF) for an overview of how to diagnose this dependence). For each model we examine three possible temporal autocorrelation structures: none, AR1, and ARMA. Summary and diagnostic plots are only presented for the best model.

### Accounting for Trail/Subsection Grouping

A key feature of these data that we need to account for in our model is the random effect of trail, and for some trails the different subsections. Both `gam` and `gamm` in the **mgcv** package can incorporate random effects through a smoothing term that, in R, would look similar to

```{r gamm-randomeffects, echo=TRUE}
re_mod <- gam(response ~ maineffect +
                s(randomeffect, bs = 're'),
              data = data,
              method = 'REML')
                
```

Note that the random effect is denoted with `bs="re"`. Multiple random effects would each have its own smoothing term in the model. Another key requirement of this application is that the random effect term must be coded as a factor term. These random effect terms are adding random intercepts (deviations from the overall mean, the model constant term) for each level of the factors.

### Global Smoothing Model (G)

We start with a simple GAMM structure with a single smooth for each of the variables.

In R we can write our model as:

```{r model G shown, echo = T, eval = F}
gamm_modG_ARMA <- gamm(max.camera ~
                         s(yday, bs="tp") +
                         s(subsectionF, bs="re", k=21) +
                         s(month, bs="tp" k = 7) +
                         s(wday, bs = "cc", k = 7) +
                         s(daily_aqi_value, bs="tp", k = 10) +
                         s(temp_max_f, bs="tp", k = 10) +
                         s(precipitation_in, bs = "tp", k = 5) +
                        s(totallength_miles,  bs="tp", k = 10) + 
                        total_traveltime +
                         max.count
                        ,
                      method = 'REML',
                       data = allTrail, 
                      correlation = corARMA(form = ~yday|subsectionF,
                                            p = 1, q = 2),
                      family = poisson, 
                      niterPQL = 20)
```

The arguments to the s() terms are smoothed. For each we explicitly specify the type of smoother to be used with the bs argument, and the maximum number of basis functions with k. The default type of smoother is the TPRS smoother ("tp") and the default value for k (for TPRS) is 10. We use a cyclic cubic spline ("cc") for day of week (wday) and set k=7 as we have seven unique values in this variable. We also set k=7 for month for the same reason; the data spans seven months of the year. If camera counters are deployed year-round in the future we would use bs="cc" and k=12 for this variable. The random effect smoother (bs="re") that we used for the subsectionF factor always has a k value equal to the number of levels in the grouping variable (here, `r length(unique(allTrail$subsectionname))`). We restrict the number of knots for `precipitation_in` (k=5) to curb some weird behavior likely due to very few non-zero values.

```{r subsection modG, eval = T, echo = F}
## Model G - Global smoother - A single common smoother for all observations
if(runall){
  ## we are fitting several versions of each Model (here, model G) with increasing temporal structure on the errors. We will report the best one in this report, but provide the code for multiple specification in case a different model is needed in the future. 
  
  
  ## explore gam() approach - OK if other parameters take care of
  ## temporal dependence (don't seem to)
  
  gam_modG <- gam(max.camera ~
                         s(yday, bs="cc") +
                        # trailnameF + 
                         s(subsectionF,
                           bs="re",
                           # by = trailnameF,
                           k=sub.number) +
                         s(month, bs = "cc",  k = 7) +
                         s(wday,
                           bs = "cc", k = 7) +
                         s(daily_aqi_value) +
                         s(temp_max_f) +
                         s(precipitation_in, k = 5) +
                        s(totallength_miles) + 
                        total_traveltime +
                         max.count,
                      knots = list(yday = c(0,365),
                                   month = c(0, 13)),
                      method = 'REML',
                       data = allTrail, 
                       family = poisson#, 
                      # niterPQL = 20 #argument only used in gamm, not gamm4
                      )
  
  ## gamm model - check if this takes care of temporal dependence as is (w/o temporal autocorr sturcture on errors)
  gamm_modG <- gamm(max.camera ~
                          s(yday, bs="cc") +
                          # trailnameF + 
                          s(subsectionF,
                            bs="re",
                            # by = trailnameF,
                            k=sub.number) +
                         s(month, bs = "cc",  k = 7) +
                          s(wday,
                            bs = "cc", k = 7) +
                          s(daily_aqi_value) +
                          s(temp_max_f) +
                          s(precipitation_in, k = 5) +
                           s(totallength_miles) + 
                        total_traveltime +
                          max.count,
                        knots = list(yday = c(0,365),
                                     month = c(0, 13)),
                        method = 'REML',
                        # correlation = corARMA(form = ~yday|subsectionF, p = 5), 
                        data = allTrail, 
                        family = poisson#, 
                        # niterPQL = 20
  )
  
 gamm_modG_AR1 <- gamm(max.camera ~
                            s(yday, bs="cc") +
                            # te(yday, precipitation_in, 
                            #   bs = c("cc", "tp"), k = c(10, 10), 
                            #   np = FALSE) +
                            # trailnameF + 
                            s(subsectionF,
                              bs="re",
                              # by = trailnameF,
                              k=sub.number) +
                         s(month, bs = "cc",  k = 7) +
                            s(wday,
                              bs = "cc", k = 7) +
                            s(daily_aqi_value) +
                            s(temp_max_f) +
                            s(precipitation_in, k = 5) +
                             s(totallength_miles) + 
                        total_traveltime +
                            max.count,
                          knots = list(yday = c(0,365),
                                       month = c(0, 13)),
                          method = 'REML',
                          correlation = corAR1(form = ~yday|subsectionF),
                          data = allTrail, 
                          family = poisson#, 
                          # niterPQL = 20
 )
  
gamm_modG_ARMA <- gamm(max.camera ~
                              s(yday, bs="cc") +
                              # trailnameF + 
                              s(subsectionF,
                                bs="re",
                                # by = trailnameF,
                                k=sub.number) +
                              s(month, k = 7) +
                              s(wday,
                                bs = "cc", k = 7) +
                              s(daily_aqi_value) +
                              s(temp_max_f) +
                              s(precipitation_in, k = 5) +
                               s(totallength_miles) + 
                        total_traveltime +
                              max.count,
                            knots = list(yday = c(0,365),
                                         month = c(0, 13)),
                            method = 'REML',
                            correlation = corARMA(form = ~yday|subsectionF,
                                                  p = 1, q = 2),
                            data = allTrail, 
                            family = poisson#,
                            # niterPQL = 30
  )

save(gam_modG, file=here("output/models/allT_subsection_gam_G.rda"),
     compress='xz')  

  save(gamm_modG, file=here("output/models/allT_subsection_gamm_G.rda"),
     compress='xz') 
  
   save(gamm_modG_AR1, file=here("output/models/allT_subsection_gamm_G-AR1.rda"),
     compress='xz')
   
   save(gamm_modG_ARMA, file=here("output/models/allT_subsection_gamm_G-ARMA.rda"),
     compress='xz')
}

load(here("output/models/allT_subsection_gam_G.rda"))
load(here("output/models/allT_subsection_gamm_G.rda"))
load(here("output/models/allT_subsection_gamm_G-AR1.rda"))
load(here("output/models/allT_subsection_gamm_G-ARMA.rda"))


```

For each model (G, GS, GI) we will use the **forecast** package to determine the optimum values of $p$ and $q$ in the ARMA correlation structure, but, for brevity, won't always report this outcome.

```{r modG pq choice, eval =T, echo=T}
## this should help find values for p and q in the ARMA model 
arma_res_G <- forecast::auto.arima(resid(gamm_modG$lme, type = "normalized"), 
                                   seasonal = T)
 
arma_res_G$coef
```

The summary and various diagnostic plots will only be shown for the "best" model (between the different correlation structures) as determined by anova. For model G, we will present the model with the ARMA correlation structure only.

```{r modG-anova, eval=TRUE}
anova(gamm_modG$lme, 
      gamm_modG_AR1$lme, 
      gamm_modG_ARMA$lme)
```

The summary output indicates that all of our included parametric (linear) coefficients and smooth terms are (approximately) significant. The effective degree of freedom (edf) values represents the complexity of the smooth. We can see in this output that the highest smooth complexity is for `subsectionF`. The adjusted R-sq value (which should not be employed as an absolute measure of model performance) is 0.805 for this model.

```{r modG summary, eval = T, echo=T}
summary(gamm_modG_ARMA$gam)
```

```{r, eval=T, result = "asis", message=F, include=knitr::is_latex_output(), echo= T, include = F}
gamtabs(gamm_modG_ARMA$gam,
        caption="Summaty of Global Smoothing Model (G)",
        comment=FALSE, type='latex')

## the output of this is copy/pasted into next latex chunck
## unsure why doesn't appear as table properly


# <!-- ```{=latex} -->
# <!-- \begin{table}[ht] -->
# <!-- \centering -->
# <!-- \begin{tabular}{lrrrr} -->
# <!--    \hline -->
# <!-- A. parametric coefficients & Estimate & Std. Error & t-value & p-value \\  -->
# <!--   (Intercept) & 2.4341 & 0.1264 & 19.2549 & $<$ 0.0001 \\  -->
# <!--   max.count & 0.0130 & 0.0003 & 37.8803 & $<$ 0.0001 \\  -->
# <!--    \hline -->
# <!-- B. smooth terms & edf & Ref.df & F-value & p-value \\  -->
# <!--   s(yday) & 7.8066 & 7.8066 & 2045.5808 & $<$ 0.0001 \\  -->
# <!--   s(subsectionF) & 23.7638 & 24.0000 & 1935.4483 & $<$ 0.0001 \\  -->
# <!--   s(wday) & 4.9576 & 5.0000 & 986.7435 & $<$ 0.0001 \\  -->
# <!--   s(daily\_aqi\_value) & 8.5560 & 8.5560 & 234.0028 & $<$ 0.0001 \\  -->
# <!--   s(temp\_max\_f) & 7.7900 & 7.7900 & 908.9799 & $<$ 0.0001 \\  -->
# <!--    \hline -->
# <!-- \end{tabular} -->
# <!-- \caption{Summaty of Global Smoothing Model (G)}  -->
# <!-- \label{tab.gam} -->
# <!-- \end{table} -->
# <!-- ``` -->

```

In figures \@ref(fig:modG-TSdiag1) and \@ref(fig:modG-TSdiag2), we examine several diagnostic plots for a time series GAMM fit. A more detailed explanation of all of these plots and how to interpret them is available in Section \@ref(Diag). We are not looking for a perfect fit with this model, rather including these diagnostic plots so that they may be compared to those from fitting the data to models GS and GI.

```{r modG-TSdiag1, eval = T, fig.align='center',  out.width = "100%", fig.cap="GAMM time series   diagnostic plots for model \\emph{G}."}
allTrail_G <- allTrail %>% 
  tidyr::drop_na(c('daily_aqi_value', "totallength_miles"))


with(allTrail_G, tsDiagGamm(gamm_modG_ARMA, timevar = yday,
                          observed = max.camera))
```

```{r modG-TSdiag2, eval = T, fig.align='center',  out.width = "100%", fig.cap="ACF/pACF diagnostic plots for model \\emph{G}."}
layout(matrix(1:2, ncol = 2))
acf(resid(gamm_modG_ARMA$lme, type = "normalized"), 
    lag.max = 36, main = "ACF")
pacf(resid(gamm_modG_ARMA$lme, type = "normalized"),
     lag.max = 36, main = "pACF")
layout(1)

```

Figure \@ref(fig:modG-draw) partial effects plots for model G with an ARMA(1,2) temporal correlation structure. Partial effects are the isolated effects of one particular predictor or interaction of predictors. The output now includes a QQ-plot for the random effects term, showing the estimated intercepts for the different levels of `subsectionF`.

```{r modG-draw, eval = T, echo=T, fig.cap="Partial effects plots for model \\emph{G}."}
gratia::draw(gamm_modG_ARMA$gam, residuals = F)
```

The rootogram plot in Figure \@ref(fig:modG-rootogram) shows that the data are slightly overdispersed (the variance, which is expected to be the same as the mean, is larger). Overdispersion for a poisson family distribution is not uncommon in real world data. Alternative families may be specified in the `gamm` code through the family argument, such as quasipoisson, negative binomial or (for `gam` only) a zero-inflated poisson family. Several alternatives were explored (not shown) but none provided improvements in overdisperson.

```{r modG-rootogram, eval = T, echo = T, fig.align='center', fig.cap="Rootogram for checking for overdispersion."}

rg <- gratia::rootogram(gamm_modG_ARMA$gam)
draw(rg)
```

```{r modG-overdispersion}
sum(residuals(gamm_modG_ARMA$gam, type = "pearson")^2) / df.residual(gamm_modG_ARMA$gam)
```

Averaging over all of the variation (between trails) results in a relatively imprecise (diffuse) estimates of trail use (Figures \@ref(fig:high-pred-G) and \@ref(fig:low-pred-G)), and viewing trail-specific plots of observed vs. predicted values (Figure \@ref(fig:modG-pred-observed)), it is apparent that the model fits some of the trail sections better than others. This model could potentially be improved by adding intergroup variation between trail subsections.

```{r modelG-pred-compare, eval = F, echo = F}
p_G_none <- as_tibble(predict(gamm_modG$gam, 
                                 predict.All, 
                                 se.fit = TRUE, 
                                 type = "response")) %>%
    rename(fit_none = fit, se_none = se.fit)
p_G_AR1 <- as_tibble(predict(gamm_modG_AR1$gam, 
                            predict.All, 
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_AR1 = fit, se_AR1 = se.fit)
p_G_ARMA <- as_tibble(predict(gamm_modG_ARMA$gam, 
                            predict.All, 
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_ARMA = fit, se_ARMA = se.fit)


pred_all_G <- bind_cols(predict.All, p_G_none, p_G_AR1, p_G_ARMA) %>%
    tidyr::pivot_longer(fit_none:se_ARMA, names_sep = '_',
                 names_to = c('variable', 'correlation')) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    mutate(upr_ci = fit + (2 * se), lwr_ci = fit - (2 * se))

compare_modG <- ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = pred_all_G,
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(correlation)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail, aes(colour = as.factor(wday))) +
    geom_line(data = pred_all_G, aes(y = fit, x = yday, colour2 = factor(correlation)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Model G",
         subtitle = "How prediction varies with different temporal correlation structures")+
  theme(text = element_text(size=18))

compare_high_G <-  ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = pred_all_G %>% filter(subsectionF %in% high_use),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(correlation)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %in% high_use), aes(colour = as.factor(wday))) +
    geom_line(data = pred_all_G  %>% filter(subsectionF %in% high_use),
              aes(y = fit, x = yday, colour2 = factor(correlation)),
              alpha= 0.7,
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Model G",
          y = "Trail Use Count",
         x = "Day of Year",
         subtitle = "How prediction varies with different temporal correlation structures")+
  theme(text = element_text(size=18))
compare_high_G

# ggsave(filename = here::here("output/figures/high_pred_compareG.pdf"),
#        plot = compare_high_G,
#        height = 8.5, 
#        width = 13,
#        dpi=700)
  
compare_low_G <-  ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = pred_all_G %>% filter(subsectionF %notin% high_use),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(correlation)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %notin% high_use), aes(colour = as.factor(wday))) +
    geom_line(data = pred_all_G  %>% filter(subsectionF %notin% high_use),
              aes(y = fit, x = yday, colour2 = factor(correlation)),
              alpha= 0.7,
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 300)) +
   facet_wrap(~subsectionF, drop = T, ncol =3) +
    labs(title = "Extrapolation",
         y = "Trail Use Count",
         x = "Day of Year",
         subtitle = "How prediction varies with different temporal correlation structures")+
  theme(text = element_text(size=18))
compare_low_G
# ggsave(filename = here::here("output/figures/low_pred_compareG.pdf"),
#        plot = compare_low_G,
#        height = 8.5, 
#        width = 13,
#        dpi=700)

```

```{r modelG-predict, eval = T, echo=FALSE}
gamm_modG_ARMA_pred <- predict(gamm_modG_ARMA$gam, se.fit=TRUE, type = "response")
allTrail_G_pred <- transform(allTrail_G, 
                 modG = gamm_modG_ARMA_pred$fit, 
                 modG_se = gamm_modG_ARMA_pred$se.fit)

all_pred_G <- ggplot(data=allTrail_G_pred, aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modG-2*modG_se),
                  ymax=(modG+2*modG_se)), alpha=0.25) +
  geom_line(aes(y=(modG), col = trailname)) +
  geom_point(aes(color = trailname)) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use"))+
  theme(text = element_text(size=18))

## turn this into two graphs with high/low trail use so scales are different and we can see low trail use subsections better

high_pred_G <- ggplot(data=filter(allTrail_G_pred, subsectionF %in% high_use),
                   aes(x=yday, y=max.camera, 
                       group=subsectionF)) +
  facet_wrap(~subsectionF, ncol = 3) +
  geom_ribbon(aes(ymin=(modG-2*modG_se),
                  ymax=(modG+2*modG_se)), alpha=0.25) +
  geom_line(aes(y=(modG), col = trailname)) +
  geom_point(aes(color = trailname), size = 1) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use")) + 
  theme(legend.position="bottom")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/high_pred_modG.png"),
       plot = high_pred_G,
       height = 8.5, 
       width = 13,
       dpi=700)

low_pred_G <- ggplot(data=filter(allTrail_G_pred, subsectionF %notin% c("NA", high_use)),
                   aes(x=yday, y=max.camera, 
                       group=subsectionF)) +
  facet_wrap(~subsectionF, ncol = 3) +
  geom_ribbon(aes(ymin=(modG-2*modG_se),
                  ymax=(modG+2*modG_se)), alpha=0.25) +
  geom_line(aes(y=(modG), col = trailname)) +
  geom_point(aes(color = trailname), size = 1) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use")) + 
  theme(legend.position="bottom")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/low_pred_modG.png"),
       plot = low_pred_G,
       height = 8.5, 
       width = 13,
       dpi=700)
```

```{r high-pred-G, eval = T , fig.align ='center', out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each high-use trail subsection, based on model \\emph{G}."}

knitr::include_graphics(path =  here::here("output/figures/high_pred_modG.png"))

```

```{r low-pred-G, eval = T, fig.align ='center', out.width = "100%",  fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each low-use trail subsection, based on model \\emph{G}."}

knitr::include_graphics(path =  here::here("output/figures/low_pred_modG.png"))
```

Model GS is able to effectively capture the obseved pattern of trial use variation between trail subsections and shows slightly less evidence of overdispersion (Figure \@ref(fig:modGS-pred-observed)) in some trail subsections compared to Model G (note the difference in Corbly Gulch).

```{r modG-pred-observed, eval = T, echo = T, fig.align ='center', fig.height= 13, fig.width=10, fig.cap="Assuming a well-fitted model G, we would expect all trail subsections exhibiting similar patterns of dispersion around the 1-1 line (and as we are assuming the data is Poisson, the variance around the mean should equal the mean). Instead we see that variance around the predicted value is much higher for some trails such as Sacagawea Pass."}

#add the predicted values from the model 
allTrail_G_pred <- transform(allTrail_G, 
                      mod_G = predict(gamm_modG_ARMA$gam, 
                                      type = "response"))

ggplot(allTrail_G_pred, aes(x=mod_G, y=max.camera)) +
  facet_wrap(~subsectionF, ncol= 3) +
  geom_point(alpha=0.5, aes(color = trailname)) +
  scale_color_manual(name = "Trail", values = colors) +
  geom_abline() +
  theme(legend.position="none") +
  labs(x="Predicted count", y="Observed count")+
  theme(text = element_text(size=18))
```

### Single common smoother plus group-level smoothers that have the same wiggliness (model GS)

Model GS constricts all groups to having similar functional responses, but, unlike model G, intergroup variation in responses is allowed. This approach works by allowing each grouping level (here, `subsectionF`) to have its own functional response, but penalizing functions that are too far from the average.

In R we can write our model as:

```{r model GS shown, echo =T, eval =F}

gamm_modGS <- gamm(max.camera ~ 
                     s(yday, m=2, bs="cc") +
                     s(yday, subsectionF,
                       m=2, bs="fs", k = 21) +
                     # s(subsectionF, bs = "re", k= 21) +
                     s(month, bs = "cc", k = 7) +
                     s(wday,
                       bs = "cc", k = 7) +
                     s(daily_aqi_value) +
                     s(temp_max_f) +
                     s(precipitation_in, k = 5) +
                     s(totallength_miles) + 
                     total_traveltime +
                     max.count,
                   knots = list(yday = c(0,365),
                                month = c(0, 13)),
                   data = allTrail, 
                   method = "REML", 
                   family = poisson)
```

With this model specification we explicitly specifying one term for the global smoother (as in model G, above) then added a second smooth term specifying the group-level smooth terms (here, `subsectionF`), using a penalty term that tends to draw these group-level smoothers toward zero. This penalty is incorporated via the factor-smoothing basis type (`bs = "fs"`) which creates a copy of each set of basis functions for each level of the grouping variable, but only estimates one smoothing parameter for all groups (see `?mgcv::factor.smooth.interaction` for details).

```{r subsection modGS, echo=F, eval=T}

if(runall){
  gamm_modGS <- gamm(max.camera ~ 
                       s(yday, bs="cc") +
                       s(yday, subsectionF,
                         m=2,
                         bs="fs", xt=list(bs="cc")) +
                       # s(subsectionF,  m=2, bs = "re", k=sub.number) +
                       # trailnameF +
                       s(month, bs = "cc",  k = 7) +
                       s(wday, bs = "cc", k = 7) +
                       s(daily_aqi_value) +
                       s(temp_max_f) +
                       s(precipitation_in, k = 5) +
                       s(totallength_miles) + 
                       total_traveltime +
                       max.count,
                     knots = list(yday = c(0,365),
                                  month = c(0, 13)),
                     data = allTrail, 
                     method = "REML",
                     family = poisson#, 
                     # niterPQL = 20
                        )
  
  gamm_modGS_AR1 <- gamm(max.camera ~ 
                           s(yday, bs="cc") +
                           s(yday, subsectionF, m=2,
                             bs="fs", xt=list(bs="cc")) +
                           # s(subsectionF,m=2, bs = "re", k = sub.number) +
                           # trailnameF +
                           s(month, bs = "cc", k = 7) +
                           s(wday,
                             bs = "cc", k = 7) +
                           s(daily_aqi_value) +
                           s(temp_max_f) +
                           s(precipitation_in, k = 5) +
                           s(totallength_miles) + 
                           total_traveltime +
                           max.count,
                         knots = list(yday = c(0,365),
                                      month = c(0, 13)),
                         data = allTrail, 
                         method = "REML", 
                         correlation = corAR1(form = ~yday|subsectionF),
                         family = poisson#, 
                         # niterPQL = 20
  )
  
  # gamm_modGS_ARMA <- gamm(max.camera ~ 
  #                           s(yday, bs="cc") +
  #                           s(yday, subsectionF,m=2,
  #                             bs="fs", k = sub.number, xt=list(bs="cc")) +
  #                           # s(subsectionF, m=2, bs = "re", k = sub.number) +
  #                           # trailnameF +
  #                           s(month, bs = "cc", k = 7) +
  #                           s(wday,
  #                             bs = "cc", k = 7) +
  #                           s(daily_aqi_value) +
  #                           s(temp_max_f) +
  #                           s(precipitation_in) +
  #                           s(totallength_miles) + 
  #                           total_traveltime +
  #                           max.count,
  #                         knots = list(yday = c(0,365),
  #                                      month = c(0, 13)),
  #                         data = allTrail, 
  #                         method = "REML", 
  #                         correlation = corARMA(form = ~yday|subsectionF, 
  #                                               p = 2, q = 2),
  #                         family = poisson #, 
  #                         # niterPQL = 20
  # )

save(gamm_modGS, file=here("output/models/allT_subsection_gamm_GS.rda"),
     compress='xz')

save(gamm_modGS_AR1, file=here("output/models/allT_subsection_gamm_GS_AR1.rda"),
     compress='xz')

# save(gamm_modGS_ARMA, file=here("output/models/allT_subsection_gamm_GS_ARMA.rda"),
#      compress='xz')
}

load(here("output/models/allT_subsection_gamm_GS.rda"))
load(here("output/models/allT_subsection_gamm_GS_AR1.rda"))
# load(here("output/models/allT_subsection_gamm_GS_ARMA.rda"))

```

```{r modGS pq choice}
## this should help find values for p and q in the ARMA model 
arma_res_GS <- forecast::auto.arima(resid(gamm_modGS$lme, type = "normalized"),
                                    seasonal = T)
 
arma_res_GS$coef
```

```{r modGS-anova}
anova(gamm_modGS$lme, 
      gamm_modGS_AR1$lme#, 
      # gamm_modGS_ARMA$lme
      )

```

Model GS without any temporal correlation structure has been selected, but the summary does not seem to work on this model fit object. However, all other diagnostic plots and predictions work.

```{r modGS summary, eval = F}
summary(gamm_modGS$gam)
```

Diagnostic plots for time series data show that this model accounts for the temporal autocorrelation in the data. 

```{r modGS-tsDiag1, eval = T, fig.align='center', out.width="100%", fig.cap="Time series diagnostic plots for Model GS."}
# gratia::appraise(gamm_modGS_ARMA$gam)

with(allTrail_G, tsDiagGamm(gamm_modGS, timevar = yday,
                          observed = max.camera))
```

```{r modGS-tsDiag2, eval = T, fig.align='center', out.width="100%", fig.cap="Temporal autocorerlation diagnostic plots for Model GS."}
# 
layout(matrix(1:2, ncol = 2))
acf(residuals(gamm_modGS$lme, type = "normalized"),
        lag.max = 36, main = "ACF")

pacf(residuals(gamm_modGS$lme, type = "normalized"),
         lag.max = 36, main = "pACF")
layout(1)
```

Figure \@ref(fig:modelGS-draw) shows the fitted smoothers for `gamm_modGS`. The plots of group-specific smoothers (bottom left) indicate that trail subsections differ not only in average (log) trail use (which would correspond to each trail having a straight line at different levels for the group-level smoother), but differ slightly in the shape of their functional responses. Figures \@ref(fig:high-pred-GS) and \@ref(fig:low-pred-GS) shows how the global and group-specific smoothers combine to predict trail use for individual trails. We see that, unlike in the single global smoother case above, none of the curves deviate from the data systematically. Some trails with notable improvement in prediction include Corbly Gulch and Middle Cottonwood. Sacagawea Pass still seems to have the highest deviation between observed and predicted values.

```{r modelGS-draw, eval= T, fig.align='center', out.width="100%", echo=FALSE, fig.cap="Global function (\\texttt{s(yday)}) and group-specific deviations from the global function (\\texttt{s(yday, subsection)}) for \\texttt{gamm\\_modGS)}. "}
#gratia draw() plot 
gratia::draw(gamm_modGS)
```

```{r modelGS-predict, echo=FALSE, eval = T}
gamm_modGS_pred <- predict(gamm_modGS$gam, se.fit=TRUE, type = "response")
allTrail_GS <- transform(allTrail_G, 
                 modGS = gamm_modGS_pred$fit, 
                 modGS_se = gamm_modGS_pred$se.fit)
all_pred_GS <- ggplot(data=allTrail_GS, aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modGS-2*modGS_se),
                  ymax=(modGS+2*modGS_se)), alpha=0.25) +
  geom_line(aes(y=(modGS))) +
  geom_point() +
  labs(x=expression("Day of Year"),
       y=expression("Trail use"))+
  theme(text = element_text(size=18))

## turn this into two graphs with high/low trail use so scales are different and we can see low trail use subsections better

high_pred_GS <- ggplot(data=filter(allTrail_GS, subsectionF %in% high_use),
                   aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modGS-2*modGS_se),
                  ymax=(modGS+2*modGS_se)), alpha=0.25) +
  geom_line(aes(y=(modGS), col = trailname)) +
  geom_point(aes(col = trailname)) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use")) + 
    theme(legend.position="bottom")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/high_pred_modGS.png"),
       plot = high_pred_GS,
       height = 8.5, 
       width = 13,
       dpi=700)

low_pred_GS <- ggplot(data=filter(allTrail_GS, subsectionF %notin% high_use),
                   aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modGS-2*modGS_se),
                  ymax=(modGS+2*modGS_se)), alpha=0.25) +
  geom_line(aes(y=(modGS), col = trailname)) +
  geom_point(aes(col = trailname)) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use")) + 
  theme(legend.position="bottom")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/low_pred_modGS.png"),
       plot = low_pred_GS,
       height = 8.5, 
       width = 13,
       dpi=700)


```

```{r high-pred-GS, eval = T , fig.align='center', out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each high-use trail subsection, based on model \\emph{GS}."}

knitr::include_graphics(path =  here::here("output/figures/high_pred_modGS.png"))

```

```{r low-pred-GS, eval = T, fig.align='center', out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each low-use trail subsection, based on model \\emph{GS}."}

knitr::include_graphics(path =  here::here("output/figures/low_pred_modGS.png"))
```

```{r modGS-pred-observed, eval = T, echo = T, fig.align='center', fig.height = 13, fig.width=10, fig.cap="Assuming a well-fitted model GS, we would expect all trail subsections exhibiting similar patterns of dispersion around the 1-1 line (and as we are assuming the data is Poisson, the variance around the mean should equal the mean)."}

#add the predicted values from the model 
allTrail_GS_pred <- transform(allTrail_G, 
                      mod_GS = predict(gamm_modGS$gam, 
                                      type = "response"))

ggplot(allTrail_GS_pred, aes(x=mod_GS, y=max.camera)) +
  facet_wrap(~subsectionF, ncol= 3) +
  geom_point(alpha=0.5, aes(color = trailname)) +
  scale_color_manual(name = "Trail", values = colors) +
  geom_abline() +
  theme(legend.position="none") +
  labs(x="Predicted count", y="Observed count")+
  theme(text = element_text(size=18))
```

```{r modelGS-pred-compare, eval = F, echo = F}
p_GS_none <- as_tibble(predict(gamm_modGS$gam, 
                                 predict.All, 
                                 se.fit = TRUE, 
                                 type = "response")) %>%
    rename(fit_none = fit, se_none = se.fit)
p_GS_AR1 <- as_tibble(predict(gamm_modGS_AR1$gam, 
                            predict.All, 
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_AR1 = fit, se_AR1 = se.fit)
# p_GS_ARMA <- as_tibble(predict(gamm_modGS_ARMA$gam, 
#                             predict.All, 
#                             se.fit = TRUE, 
#                             type = "response")) %>%
#     rename(fit_ARMA = fit, se_ARMA = se.fit)


pred_all_GS <- bind_cols(predict.All, p_GS_none, p_GS_AR1
                         # , p_GS_ARMA
                         ) %>%
    tidyr::pivot_longer(fit_none:se_AR1, names_sep = '_',
                 names_to = c('variable', 'correlation')) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    mutate(upr_ci = fit + (2 * se), lwr_ci = fit - (2 * se))

compare_modGS <- ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = pred_all_GS,
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(correlation)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail, aes(colour = as.factor(wday))) +
    geom_line(data = pred_all_GS, aes(y = fit, x = yday, colour2 = factor(correlation)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Model GS",
         subtitle = "How prediction varies with different temporal correlation structures")

compare_high_GS <-  ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = pred_all_GS %>% filter(subsectionF %in% high_use),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(correlation)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %in% high_use), aes(colour = as.factor(wday))) +
    geom_line(data = pred_all_GS  %>% filter(subsectionF %in% high_use),
              aes(y = fit, x = yday, colour2 = factor(correlation)),
              alpha= 0.7,
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Model GS",
         subtitle = "How prediction varies with different temporal correlation structures")
compare_high_GS

# ggsave(filename = here::here("output/figures/high_pred_compareG.pdf"),
#        plot = compare_high_G,
#        height = 8.5, 
#        width = 13,
#        dpi=700)
  
compare_low_GS <-  ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = pred_all_GS %>% filter(subsectionF %notin% high_use),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(correlation)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %notin% high_use), aes(colour = as.factor(wday))) +
    geom_line(data = pred_all_GS  %>% filter(subsectionF %notin% high_use),
              aes(y = fit, x = yday, colour2 = factor(correlation)),
              alpha= 0.7,
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 300)) +
   facet_wrap(~subsectionF, drop = T, ncol =3) +
    labs(title = "Extrapolation",
         subtitle = "How prediction varies with different temporal correlation structures")
compare_low_GS
# ggsave(filename = here::here("output/figures/low_pred_compareG.pdf"),
#        plot = compare_low_G,
#        height = 8.5, 
#        width = 13,
#        dpi=700)

```

### Single common smoother plus group-level smoothers with differing wiggliness (Model GI)

In this model class each group-specific smoother is permitted to have its own smoothing parameter and hence its own level of wiggliness. These models take the longest to run (as there are more smoothing parameters to estimate), but is useful if the different groups (here, trail subsections) differ in how 'wiggly' they are.

There are two major differences in how model GS was specified:

1.  Explicit inclusion of a random effect for the intercept (the bs="re" term).

2.  Specify m=1 instead of m=2 for the group-level smoothers. This allows for the marginal TPRS basis for relevent terms will penalize the squared first derivative of the function, rather than the second derivative. The aim is to reduce colinearity between the global smoother and the group-specific terms.

This approach in R looks like:

```{r model GI shown, echo = T}

 gamm_modGI_AR1 <- gamm(max.camera ~
                           s(yday, m=2, bs="cc") +
                           s(yday, by = subsectionF,
                             m=1, bs="cc") +
                           s(subsectionF,
                             bs="re",
                             # by = trailnameF,
                             k=21) +
                           # trailnameF +
                           s(month, bs = "cc",  k = 7) +
                           s(wday,
                             bs = "cc", k = 7) +
                           s(daily_aqi_value) +
                           s(temp_max_f) +
                           s(precipitation_in, k = 5) +
                          s(totallength_miles) + 
                        total_traveltime +
                            max.count,
                          knots = list(yday = c(0,365),
                                       month = c(0, 13)),
                           correlation = corAR1(form = ~yday|subsectionF),
                         data = allTrail,
                         family = poisson)
```

When including a by-variable smooth, you are allowing for different smoothness parameters for each level of `subsectionF`.

```{r subsection modGI, eval = T}

if(runall){
  gamm_modGI <- gamm(max.camera ~
                                  s(yday, m=2, bs="cc") +
                                  s(yday, by = subsectionF,
                                    m=1, bs="cc") +
                                  s(subsectionF,
                                    bs="re",
                                    # by = trailnameF,
                                    k=sub.number) +
                                  # trailnameF +
                                  s(month, bs = "cc", k = 7) +
                                  s(wday,
                                    bs = "cc", k = 7) +
                                  s(daily_aqi_value) +
                                  s(temp_max_f) +
                                  s(precipitation_in, k = 5) +
                                  s(totallength_miles) + 
                        total_traveltime +
                            max.count,
                          knots = list(yday = c(0,365),
                                       month = c(0, 13)),
                                data = allTrail,
                                family = poisson)

# gamm4_modGI2_sub <- gamm4::gamm4(max.camera ~ 
#                                    s(yday, bs="tp") +
#                                    s(subsectionF, bs = "re")+
#                                    s(yday, by= subsectionF) +
#                                    s(wday,
#                                      bs = "cc", k = 7) +
#                                    s(daily_aqi_value) +
#                                    s(temp_max_f) +
#                                    s(precipitation_in) +
#                                    max.count
#                                  ,
#                                  data = allTrail, 
#                                  family = poisson#, 
#                                  # method = "REML"
# )
  
  # gamm_modGI2_sub <- gamm(max.camera ~ 
#                          s(yday, m=2, bs="tp") + 
#                           s(subsectionF, bs = "re") +
#                          s(yday, by = subsectionF,
#                            m=1, bs="tp") +
#                          # s(subsectionF,
#                          #   bs="re", by = trailnameF, k=25) +
#                          trailnameF +
#                          s(month, k = 7) +
#                          s(wday,
#                            bs = "cc", k = 7) +
#                          s(daily_aqi_value) +
#                          s(temp_max_f) +
#                          s(precipitation_in) +
#                          max.count,
#                        data = allTrail, 
#                        family = poisson)
# 
# save(gamm_modGI, file=here("output/models/allT_subsection_gamm_GI.rda"),
#      compress='xz')
  
  gamm_modGI_AR1 <- gamm(max.camera ~
                           s(yday, m=2, bs="cc") +
                           s(yday, by = subsectionF,
                             m=1, bs="cc") +
                           s(subsectionF,
                             bs="re",
                             # by = trailnameF,
                             k=sub.number) +
                           # trailnameF +
                           s(month, bs = "cc",  k = 7) +
                           s(wday,
                             bs = "cc", k = 7) +
                           s(daily_aqi_value) +
                           s(temp_max_f) +
                           s(precipitation_in, k = 5) +
                          s(totallength_miles) + 
                        total_traveltime +
                            max.count,
                          knots = list(yday = c(0,365),
                                       month = c(0, 13)),
                           correlation = corAR1(form = ~yday|subsectionF),
                         data = allTrail,
                         family = poisson)
  
  # gamm_modGI_ARMA_sub <- gamm(max.camera ~
  #                          s(yday, m=2, bs="cc") +
  #                          s(yday, by = subsectionF,
  #                            m=1, bs="cc") +
  #                          s(subsectionF,
  #                            bs="re",
  #                            # by = trailnameF,
  #                            k=25) +
  #                          # trailnameF +
  #                          s(month, k = 7) +
  #                          s(wday,
  #                            bs = "cc", k = 7) +
  #                          s(daily_aqi_value) +
  #                          s(temp_max_f) +
  #                          s(precipitation_in, k = 5) +
  #                          s(totallength_miles) + 
  #                       total_traveltime +
  #                           max.count,
  #                         knots = list(yday = c(0,365)),
  #                          correlation = corARMA(form = ~yday|subsectionF, 
  #                                                p = 1, q = 1),
  #                        data = allTrail,
  #                        family = poisson)

save(gamm_modGI, 
     file=here("output/models/allT_subsection_gamm_GI.rda"),
     compress='xz')

save(gamm_modGI_AR1, 
     file=here("output/models/allT_subsection_gamm_GI-AR1.rda"),
     compress='xz')

# save(gamm_modGI_ARMA_sub, 
#      file=here("output/models/allT_subsection_gamm_GI-ARMA.rda"),
#      compress='xz')
}

load(file=here("output/models/allT_subsection_gamm_GI.rda"))
load(file=here("output/models/allT_subsection_gamm_GI-AR1.rda"))

# load(file=here("output/models/allT_subsection_gamm_GI-ARMA.rda"))

```

```{r modGI pqchoice}
## this should help find values for p and q in the ARMA model 
arma_res_GI <- forecast::auto.arima(resid(gamm_modGI$lme, 
                                          type = "normalized"),
                      seasonal = TRUE)
 
arma_res_GI$coef
```

Here, we present the summary and diagnostic plots for model GI with an AR1 temporal structure. 

```{r modelGI-anova, eval = T}
anova(gamm_modGI$lme, 
      gamm_modGI_AR1$lme)
```
The summary now includes all the different day of year (`yday`) by trail subsection (`subsectionF`) parameters. 
```{r modelGI-summary, eval = T}

summary(gamm_modGI$gam)
```

Figure \@ref(fig:modelGI-draw) shows a subsample of the group-specific smoothers from this model. Some trail subsections (e.g., East Bridger South) have very similar shapes to the global smoother. Others do differ from this trend with lower trail use earlier in the year and higher in later times (e.g., College M) or a mix of variations from the global trend (e.g., Corbly Gulch, Sacagawea Pass, Steep Way).

```{r modelGI-draw, eval =T, fig.align='center', fig.cap="Subsection of partial effect plots for model \\emph{GI}."}
# itsadug::check_resid(gamm_modGI_AR1$gam)

gratia::draw(gamm_modGI, select = c(1, 5, 6, 7, 18, 19))
# gratia::appraise(bam_modGI_sub)
```

Figures \@ref(fig:modelGI-tsDiag1) and \@ref(fig:modelGI-tsDiag2)  shows that model GI is the first and only model to fully capture the temporal autocorrelation (through the AR1 structure). There is only slight evidence for overdispersion (Figures \@ref(fig:GIrootogram) and \@ref(fig:modGI-pred-observed)) which seems most likely due to a slightly zero-inflated distribution.

```{r modelGI-tsDiag1, eval = T, fig.align='center',  out.width = "100%", fig.cap="Times series diagnosis plots for model \\emph{GI}."}
with(allTrail_G, tsDiagGamm(gamm_modGI, timevar = yday,
                          observed = max.camera))
```

```{r modelGI-tsDiag2, eval = T, fig.align='center', fig.cap="Times series ACF/pACF diagnosis plots for model \\emph{GI}."}

layout(matrix(1:2, ncol = 2))
acf(resid(gamm_modGI$lme, type = "normalized"),
    lag.max = 36, main = "ACF")
pacf(resid(gamm_modGI$lme, type = "normalized"),
     lag.max = 36, main = "pACF")
layout(1)

```


```{r GIrootogram, eval = T, echo = T, fig.align='center', out.width= "100%", fig.cap="Rootogram for checking overdispersion in model GI."}

rg <- gratia::rootogram(gamm_modGI$gam)
draw(rg)
```

```{r}
sum(residuals(gamm_modGI$gam, type = "pearson")^2) / df.residual(gamm_modGI$gam)


```

```{r}
## AR1 with rho - needs to define the multiple time series for each subsection
# allTrail2 <- itsadug::start_event(allTrail, 
#                                   column="yday",
#                                   event="subsectionF",
#                                   newcode = T)

allTrail <- allTrail %>% 
  dplyr::group_by(subsectionF) %>% 
  mutate(start.event = ifelse(min(yday) == yday, TRUE, FALSE)) %>% 
  dplyr::ungroup()
# valRho <- acf(resid(bam_modGI_sub), plot=FALSE)$acf[2]
# 
# 
# bam_modGI_AR1_sub <- bam(max.camera ~ 
#                          s(yday, bs="tp") +
#                          s(subsectionF, bs = "re")+
#                          s(yday, by= subsectionF) +
#                          s(wday,
#                            bs = "cc", k = 7) +
#                          s(daily_aqi_value) +
#                          s(temp_max_f) +
#                          s(precipitation_in) +
#                          max.count,
#                        data = allTrail, 
#                        family = poisson,
#                        AR.start=allTrail$start.event, 
#                        rho=valRho)
# save(bam_modGI_AR1_sub,
#      here("output/models/allT_subsection_bam_GIAR1.rda"),
#      compress='xz')

# gratia::appraise(bam_modGI_AR1_sub)

# layout(matrix(1:2, ncol = 2))
# acf(resid(bam_modGI_AR1_sub), 
#     lag.max = 36, main = "ACF")
# pacf(resid(bam_modGI_AR1_sub),
#      lag.max = 36, main = "pACF")
# layout(1)
```

```{r modGI-pred-observed, eval = T, echo = T, fig.height=13, fig.width=10, fig.cap="Assuming a well-fitted model GI, we would expect all trail subsections exhibiting similar patterns of dispersion around the 1-1 line (and as we are assuming the data is Poisson, the variance around the mean should equal the mean)."}

#add the predicted values from the model 
allTrail_GI_pred <- transform(allTrail_G, 
                      mod_GI = predict(gamm_modGI$gam, 
                                      type = "response"))

ggplot(allTrail_GI_pred, aes(x=mod_GI, y=max.camera)) +
  facet_wrap(~subsectionF, ncol= 3) +
  geom_point(alpha=0.5, aes(color = trailname)) +
  scale_color_manual(name = "Trail", values = colors) +
  geom_abline() +
  theme(legend.position="none") +
  labs(x="Predicted count", y="Observed count")+
  theme(text = element_text(size=18))
```

```{r modelGI-predict, eval = T, echo=FALSE}
gamm_modGI_AR1_pred <- predict(gamm_modGI$gam, se.fit=TRUE, type = "response")
allTrail_GI <- transform(allTrail_G, 
                 modGI = gamm_modGI_AR1_pred$fit, 
                 modGI_se = gamm_modGI_AR1_pred$se.fit)
all_pred_GI <- ggplot(data=allTrail_GI, aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modGI-2*modGI_se),
                  ymax=(modGI+2*modGI_se)), alpha=0.25) +
  geom_line(aes(y=(modGI))) +
  geom_point() +
  labs(x=expression("Day of Year"),
       y=expression("Trail use"))+
  theme(text = element_text(size=18))

## turn this into two graphs with high/low trail use so scales are different and we can see low trail use subsections better

high_pred_GI <- ggplot(data=filter(allTrail_GI, subsectionF %in% high_use),
                   aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modGI-2*modGI_se),
                  ymax=(modGI+2*modGI_se)), alpha=0.25) +
  geom_line(aes(y=(modGI), col = trailname)) +
  geom_point(aes(col= trailname)) +
  ylim(0, 800) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use")) + 
  theme(legend.position="bottom")+
  theme(text = element_text(size=18))
  
ggsave(filename = here::here("output/figures/high_pred_modGI.png"),
       plot = high_pred_GI,
       height = 8.5, 
       width = 13,
       dpi=700)

low_pred_GI <- ggplot(data=filter(allTrail_GI, subsectionF %notin% high_use),
                   aes(x=yday, y=max.camera, group=subsectionF)) +
  facet_wrap(~subsectionF) +
  geom_ribbon(aes(ymin=(modGI-2*modGI_se),
                  ymax=(modGI+2*modGI_se)), alpha=0.25) +
    geom_line(aes(y=(modGI), col = trailname)) +
  geom_point(aes(col= trailname)) +
  ylim(0,200) +
  labs(x=expression("Day of Year"),
       y=expression("Trail use")) + 
  theme(legend.position="bottom")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/low_pred_modGI.png"),
       plot = low_pred_GI,
       height = 8.5, 
       width = 13,
       dpi=700)

```

Figures \@ref(fig:high-pred-GI) and \@ref(fig:low-pred-GI) show the predictive values and observed data points for model GI.

```{r high-pred-GI, eval = T ,  out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each high-use trail subsection, based on model \\emph{GI}."}

knitr::include_graphics(path =  here::here("output/figures/high_pred_modGI.png"))

```

```{r low-pred-GI, eval = T,  out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each low-use trail subsection, based on model \\emph{GI}."}

knitr::include_graphics(path =  here::here("output/figures/low_pred_modGI.png"))
```

## Prediction/Forecasting

<!--# [X]-compare top version of each model type (G, GS, GI) [X]-compare Middle Cottonwood singleTrail to allTrail [ ]-predict at new trails [X]- save files of model comparison for each subsection (individual plots for better viewing, may not be in report; possibly in appendix?) [ ] - animated spatial maps color by prediction value (and residuals) -->

Up until this point we have looked at predictions for in-sample data. Effectively interpolating with our predictions. To examine the usefulness of these models for forecasting (i.e. predicting trail use in the near future) we may look at how these models handle temporal extrapolation (i.e. prediction outside of the range of data used to fit the models). We discussed in Section \@ref(MidCotPred) that extrapolation in the GA(M)M framework can be tricky due to how the model uses splines to learn from the data via the basis functions.

### In-Sample Trail Use Predictions

Figures \@ref(fig:high-compare-pred) and \@ref(fig:low-compare-pred) both show predicted trail use for the best model within each G, GS, and GI for the entire year of 2021. Observed trail use counts are plotted (colored by day of week). Both Models GS and GI show improvement over Model G, which is to be expected due to increase variability between trail subsections. Some trail subsections (e.g. Steep Way) still show unreasonably high predictions (and large error ribbons), however trails with a longer duration of observations (e.g. Baldy to Bridger) show improvement. Several model specification choices have improved these predictions over past iterations of models (not shown). For example, the use of cyclic cubic splines for time predictor variables (`bs= "cc"`) allows information from winter observations late in the year to inform predictions for early in the year. Also, restricting the number of knots for `precipitation_in` (now $k=5$ when before it was allowed to default to $k=10$) has removed some odd jumps in predictions on days with high precipitation. One notable difficulty for these models across all trails is the ability to predict higher than typical trail use days.

```{r compare model type predictions, eval = T}
p_G <- as_tibble((predict(gamm_modG_ARMA$gam, 
                          predict.All, 
                          se.fit = TRUE, 
                          type = "response"))) %>% 
    rename(fit_G = fit, se_G = se.fit, )
p_GS <- as_tibble(predict(gamm_modGS$gam, 
                            predict.All, 
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_GS = fit, se_GS = se.fit)
p_GI <- as_tibble(predict(gamm_modGI$gam, 
                            predict.All, 
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_GI = fit, se_GI = se.fit)


new_data_bases <- bind_cols(predict.All, p_G, p_GS, p_GI) %>%
    tidyr::pivot_longer(fit_G:se_GI, names_sep = '_',
                 names_to = c('variable', 'model')) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    mutate(upr_ci = fit + (2 * se), lwr_ci = fit - (2 * se))

compare_models <- ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = new_data_bases,
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(model)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail, aes(colour = as.factor(wday))) +
    geom_line(data = new_data_bases, aes(y = fit, x = yday, colour2 = factor(model)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Extrapolation",
          x = "Day of Year", 
         y = "Trail Use Count",
         subtitle = "How prediction varies with different model specifications")+
  theme(text = element_text(size=18))

compare_high <-  ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = new_data_bases %>% filter(subsectionF %in% high_use),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(model)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %in% high_use), aes(colour = as.factor(wday))) +
    geom_line(data = new_data_bases  %>% filter(subsectionF %in% high_use),
              aes(y = fit, x = yday, colour2 = factor(model)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Extrapolation",
          x = "Day of Year", 
         y = "Trail Use Count",
         subtitle = "How prediction varies with different model specifications")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/high_pred_compare.png"),
       plot = compare_high,
       height = 8.5, 
       width = 13,
       dpi=700)
  
compare_low <-  ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = new_data_bases %>% filter(subsectionF %notin% high_use),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(model)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %notin% high_use), aes(colour = as.factor(wday))) +
    geom_line(data = new_data_bases  %>% filter(subsectionF %notin% high_use),
              aes(y = fit, x = yday, colour2 = factor(model)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 300)) +
   facet_wrap(~subsectionF, drop = T, ncol =3) +
    labs(title = "Extrapolation",
          x = "Day of Year", 
         y = "Trail Use Count",
         subtitle = "How prediction varies with different model specifications")+
  theme(text = element_text(size=18))

ggsave(filename = here::here("output/figures/low_pred_compare.png"),
       plot = compare_low,
       height = 8.5, 
       width = 13,
       dpi=700)
```

```{r pred-subsection}

### save for each individual subsectionF
subsection.unique <- unique(new_data_bases$subsectionF)

for(s in subsection.unique){
   ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = new_data_bases %>% filter(subsectionF %in% s),
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(model)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = allTrail %>% filter(subsectionF %in% s), aes(colour = as.factor(wday))) +
    geom_line(data = new_data_bases  %>% filter(subsectionF %in% s),
              aes(y = fit, x = yday, colour2 = factor(model)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   # facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = paste0("Extrapolation: ", s),
         x = "Day of Year", 
         y = "Trail Use Count",
         subtitle = "How prediction varies with different model specifications")+
  theme(text = element_text(size=18))

ggsave(filename = here::here(paste0("output/figures/pred_compare_",
                                    s, ".png")),
       height = 8.5, 
       width = 13,
       dpi=700)
}

```

```{r high-compare-pred, eval = T ,fig.align='center',  out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each high-use trail subsection over an entire year, based on each model (\\emph{G}, \\emph{GS}, and \\emph{GI}). Observed trip counts (data points) are colored by day of the week and show the higher use on weekends. "}

knitr::include_graphics(path =  here::here("output/figures/high_pred_compare.png"))

```

```{r low-compare-pred, eval = T, fig.align = 'center', out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for each low-use trail subsection, based on each model (\\emph{G}, \\emph{GS}, and \\emph{GI})."}

knitr::include_graphics(path =  here::here("output/figures/low_pred_compare.png"))
```

### Single Trail vs All Trail Model Predictions

In Section \@ref(MidCot), we conduced a GAM analysis using only the Middle Cottonwood trail data. In Figure \@ref(fig:compareMC) we are now able to compare year-round predictions using models fit with just this single trail dataset (blue line) versus the model GI build with all available trail use data (orange line). We can see the improvement tahat our joint model provides by leveraging data across multiple trails. 

```{r compareMC, eval = T, fig.align='center', out.width = "100%", fig.cap="Comparison of model predictions when fit with only Middle Cottonwood data versus model fit with all available trail data."}
load(file = here("output/models/singleT_gamm2.rda"))

p_single <- as_tibble(predict(gamm_mod2$gam, 
                                 predict.MidCot, 
                                 se.fit = TRUE, 
                                 type = "response")) %>%
    rename(fit_single = fit, se_single = se.fit)
p_all <- as_tibble(predict(gamm_modGI$gam, 
                            predict.MidCot, 
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_all = fit, se_all = se.fit)



new_data_bases <- bind_cols(predict.MidCot, p_single, p_all) %>%
    tidyr::pivot_longer(fit_single:se_all, names_sep = '_',
                 names_to = c('variable', 'data_used')) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    mutate(upr_ci = fit + (2 * se), lwr_ci = fit - (2 * se)) #%>% 
  # dplyr::filter(subsectionF == "Middle Cottonwood")

ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = new_data_bases,
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(data_used)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = singleTrail, aes(colour = wday)) +
    geom_line(data = new_data_bases, aes(y = fit, x = yday, colour2 = factor(data_used)),
              size = 1) %>%
  # facet_wrap(~subsectionF, col = 5) %>% 
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_distiller(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Data Used") +
    scale_fill_OkabeIto(name = "Data Used") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
    labs(title = "Extrapolation",
         x = "Day of Year",
         y = "Trail Use Counts",
         subtitle = "How prediction varies with data used to fit model") +
    theme(text = element_text(size=18))

```

### Out of Sample Trail Use Predictions

Figure \@ref(fig:predict-newtrails) shows predictions from the top model within each category for trails in Bridger Mountains without deployed camera counters. All other covariate data is available for the year 2021. 

```{r predict-newtrails, eval = T, fig.align='center',  out.width = "100%", fig.cap="Predicitons at Bridger Mountain trails without deployed camera counters."}
# sapply(gamm_modG_ARMA$gam$smooth, "[[",  "label")
# sapply(gamm_modGS_AR1$gam$smooth, "[[",  "label")
# sapply(gamm_modGI_AR1$gam$smooth, "[[",  "label")

p_G_new <- as_tibble(predict(gamm_modG_ARMA$gam, 
                            predict.New, 
                            exclude = c("s(subsectionF)"),
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_G = fit, se_G = se.fit)

p_GS_new <- as_tibble(predict(gamm_modGS$gam, 
                            predict.New, 
                            exclude = c("s(subsectionF)", 
                                        "s(yday,subsectionF)"),
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_GS = fit, se_GS = se.fit)

p_GI_new <- as_tibble(predict(gamm_modGI$gam, 
                            predict.New, 
                            exclude = c("s(subsectionF)", 
                                        "s(yday):subsectionFBridger Ridge - All",
                                        # "s(yday):subsectionFBaldy to Bridger",
                                        "s(yday):subsectionFBenchmark Rd",
                                        # "s(yday):subsectionFBridger", 
                                        # "s(yday):subsectionFBridger to Ross Pass",
                                        "s(yday):subsectionFCarroll Creek",
                                        "s(yday):subsectionFCollege M",
                                        "s(yday):subsectionFCollege M to Sypes",
                                        "s(yday):subsectionFCorbly Gulch",
                                        "s(yday):subsectionFEast Bridger North",
                                        "s(yday):subsectionFEast Bridger South",
                                        "s(yday):subsectionFFairy Creek",
                                        "s(yday):subsectionFHorsethief Mountain",
                                        "s(yday):subsectionFJohnson Canyon Jeep Trail",
                                        "s(yday):subsectionFLower Shafthouse",
                                        # "s(yday):subsectionFM to Baldy",
                                        "s(yday):subsectionFMiddle Cottonwood",
                                        "s(yday):subsectionFNorth Cottonwood Access",
                                        "s(yday):subsectionFNorth Cottonwood to Johnson Canyon",
                                        "s(yday):subsectionFRaptor View",
                                        "s(yday):subsectionFRoss Pass",
                                        # "s(yday):subsectionFRoss Pass to Sacagawea Peak",
                                        "s(yday):subsectionFSacagawea Pass",
                                        "s(yday):subsectionFSteep Way",
                                        "s(yday):subsectionFSypes Canyon",
                                        "s(yday):subsectionFTruman Gulch" ),
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_GI = fit, se_GI = se.fit)

missing.spatial.New <- unique(predict.New[is.na(predict.New$total_traveltime), "subsectionname"])

new_data_bases2 <- bind_cols(predict.New, p_G_new, p_GS_new,  p_GI_new) %>%
    tidyr::pivot_longer(fit_G:se_GI, names_sep = '_',
                 names_to = c('variable', 'model')) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    mutate(upr_ci = fit + (2 * se), lwr_ci = fit - (2 * se)) %>% 
  tidyr::drop_na(total_traveltime)

compare_models_newtrails <- ggplot(mapping = aes(x = yday, y = max.count)) +
    geom_ribbon(data = new_data_bases2,
                mapping = aes(ymin = lwr_ci, ymax = upr_ci, x = yday, fill = factor(model)),
                inherit.aes = FALSE, alpha = 0.2) +
  geom_point(data = predict.New %>% tidyr::drop_na(total_traveltime), 
             aes(colour = as.factor(wday))) +
  geom_line(data = new_data_bases2, 
            aes(y = fit, x = yday, colour2 = factor(model)),
            size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
   facet_wrap(~subsectionF, drop = T, ncol = 3) +
    labs(title = "Extrapolation at new trails",
         y = "Trail Use Counts", 
         x = "Day of Year",
         subtitle = "How prediction varies with different model specifications") +
    theme(text = element_text(size=18))


compare_models_newtrails
```

### Hold-out Sample Trail Use Predictions

Our goal to select the model that has the best predictive ability across various trail types. This can be checked by holding some fraction of the data out (e.g., a single trail subsection) prior to the analysis and comparing how well different models fit that data. To this end, we have left out the New World Gulch trail and fit our selected model for each type (G, GS, GI) to these out-of-sample data. Figure \@ref(fig:NWG-pred) shows predictions from the top model within each category for the New World Gulch trail. Camera counter observations are available for this trail and were left out of the analysis to provide a means for examining predictive ability when applying model fits to new trails. All other covariate data is available for the year 2021. 

```{r compare NWG predictions, eval = T}
p_G_NWG <- as_tibble((predict(gamm_modG_ARMA$gam, 
                          NWG_2021, 
                          se.fit = TRUE, 
                          type = "response"))) %>% 
    rename(fit_G = fit, se_G = se.fit, )
p_GS_NWG <- as_tibble((predict(gamm_modGS$gam, 
                            NWG_2021, 
                              exclude = c("s(subsectionF)",
                                        "s(yday,subsectionF)"),
                            se.fit = TRUE, 
                            type = "response"))) %>%
    rename(fit_GS = fit, se_GS = se.fit)
p_GI_NWG <- as_tibble(predict(gamm_modGI$gam, 
                            NWG_2021, 
                            exclude = c("s(subsectionF)", 
                                        "s(yday):subsectionFBridger Ridge - All",
                                        # "s(yday):subsectionFBaldy to Bridger",
                                        "s(yday):subsectionFBenchmark Rd",
                                        # "s(yday):subsectionFBridger", 
                                        # "s(yday):subsectionFBridger to Ross Pass",
                                        "s(yday):subsectionFCarroll Creek",
                                        "s(yday):subsectionFCollege M",
                                        "s(yday):subsectionFCollege M to Sypes",
                                        "s(yday):subsectionFCorbly Gulch",
                                        "s(yday):subsectionFEast Bridger North",
                                        "s(yday):subsectionFEast Bridger South",
                                        "s(yday):subsectionFFairy Creek",
                                        "s(yday):subsectionFHorsethief Mountain",
                                        "s(yday):subsectionFJohnson Canyon Jeep Trail",
                                        "s(yday):subsectionFLower Shafthouse",
                                        # "s(yday):subsectionFM to Baldy",
                                        "s(yday):subsectionFMiddle Cottonwood",
                                        "s(yday):subsectionFNorth Cottonwood Access",
                                        "s(yday):subsectionFNorth Cottonwood to Johnson Canyon",
                                        "s(yday):subsectionFRaptor View",
                                        "s(yday):subsectionFRoss Pass",
                                        # "s(yday):subsectionFRoss Pass to Sacagawea Peak",
                                        "s(yday):subsectionFSacagawea Pass",
                                        "s(yday):subsectionFSteep Way",
                                        "s(yday):subsectionFSypes Canyon",
                                        "s(yday):subsectionFTruman Gulch" ),
                            se.fit = TRUE, 
                            type = "response")) %>%
    rename(fit_GI = fit, se_GI = se.fit)


new_data_NWG <- bind_cols(NWG_2021, p_G_NWG, p_GS_NWG, p_GI_NWG) %>%
    tidyr::pivot_longer(fit_G:se_GI, names_sep = '_',
                 names_to = c('variable', 'model')) %>%
    tidyr::pivot_wider(names_from = variable, values_from = value) %>%
    mutate(upr_ci = fit + (2 * se), lwr_ci = fit - (2 * se))

compare_NWG <- ggplot(mapping = aes(x = yday, y = max.camera)) +
    geom_ribbon(data = new_data_NWG,
                mapping = aes(ymin = lwr_ci, ymax = upr_ci,
                              x = yday, fill = factor(model)),
                inherit.aes = FALSE, alpha = 0.2) +
    geom_point(data = NWG_2021, aes(colour = as.factor(wday))) +
    geom_line(data = new_data_NWG, aes(y = fit, x = yday, colour2 = factor(model)),
              size = 1) %>%
    relayer::rename_geom_aes(new_aes = c("colour" = "colour2")) +
    scale_colour_brewer(palette = "Set1", aesthetics = "colour", 
                        name = "Day of Week") +
    scale_colour_OkabeIto(aesthetics = "colour2", name = "Model") +
    scale_fill_OkabeIto(name = "Model") +
    # coord_cartesian(xlim = c(0, 365), ylim = c(0, 1000)) +
    labs(title = "New World Gulch",
         y = "Trail Use Counts",
         x = "Day of Year", 
         subtitle = "How well do predictions compare with hold out data")+
    theme(text = element_text(size=18))


ggsave(filename = here::here("output/figures/NWG_pred_compare.png"),
       plot = compare_NWG,
       height = 8.5, 
       width = 13,
       dpi=700)
```

```{r NWG-pred, eval = T, fig.align = 'center', out.width = "100%", fig.cap="Predicted trail use count values (lines) versus observed trail use (points) for New World Gulch trail (hold out data not included in model fit), based on each model (\\emph{G}, \\emph{GS}, and \\emph{GI})."}

knitr::include_graphics(path =  here::here("output/figures/NWG_pred_compare.png"))
```


<!-- To be added (hopefully) animated plots of prediction values and residuals plotted spatially. Currently these animations are super cursed and are not yet up and running. -->

```{r gganimate}
cameras_sf <- st_as_sf(cameras, coords = c("counter_long", "counter_lat"), 
                   crs = 4326, agr = "constant")


# mapview::mapview(trail_spatial_summary_keep$geometry,
#                  color = "red")

fit_pred_spatial <- new_data_bases %>% 
  dplyr::left_join(trail_spatial_summary_keep, by = c("subsectionF" = "subsectionname"))

base.data <- fit_pred_spatial %>% 
  dplyr::filter(NAME %notin% c("NEW WORLD GULCH"),
                subsectionF %notin% c("Bridger")#, #missing spatial info
                # yday %in% c(200)
                ) %>%
  tidyr::drop_na(fit) %>% #summary()
  st_as_sf() %>% 
  st_zm()

base.map <- trail_spatial_summary_keep %>%
  dplyr::filter(NAME %notin% c("NEW WORLD GULCH")
                # yday %in% c(200)
                ) %>%
  st_as_sf() %>%
  st_zm() %>%
  ggplot() +
  geom_sf(
    # aes(color = fit),
    alpha = 0.3,
    size = 2
    ) +
 # scale_color_viridis_c(name = 'Trail Use Estimate', 
 #                       limits = c(0, 1000)) +
  geom_sf(data = cameras_sf,
          aes(
            # x = counter_long,
            # y = counter_lat, 
            color = trailname),
          alpha = 0.5,
          size = 2) +
  scale_color_manual(name = "Trail", values = colors) +
  ggspatial::annotation_scale(style = 'ticks', pad_x = unit(4.35, 'cm'), 
                   pad_y = unit(.5, 'cm')) +
  labs(title='Bridger Mountains Trail Predictions') +
  labs(x = "Longitude", y = "Latitude", size = 20) +
   labs(color='Trails') +
theme(axis.text = element_text(size = rel(1.25)),
      axis.title = element_text(size = rel(1.25)),
      plot.title = element_text(size = rel(2)))
base.map

animate1 <- base.map +
    ggnewscale::new_scale_color() +
  geom_sf(data = base.data %>% filter(yday %in% 200:210),
    aes(color = fit),
    size = 2
    ) +
  viridis::scale_color_viridis(limits = c(0, 1000)) +
 gganimate::transition_time(yday)# +
  # labs(title = "Day of Year: {frame_time}")
  
  nframesAnim <- length(unique(fit_pred_spatial$yday)) * 5
durationAnim <- 1
  
  gif1 <- gganimate::animate(plot = animate1, 
                height = 768,
                width =1800,
                nframes = nframesAnim,
                duration = durationAnim,
                end_pause = 10)
  
  # gif1
  
  # magick::image_write(gif1, path=here("output/figures/gganimate_test1.gif"))

  anim_save(here("output/figures/gganimate_test3.gif"), gif1)


```

```{r, animiate-timeline}
# Select first and last date to interpolate between
# For some reason this is smoother than letting gganimate do every single point
g <- fit_pred_spatial$date

plot_timeline <- 
  ggplot(g, aes(x = date, y = 1)) + 
  geom_point(aes(group = 1L), size = 5) + 
  scale_x_datetime(date_labels = "%b %d", date_breaks = "1 week") +

  theme(aspect.ratio = 0.025,
        legend.position = "none",
        axis.text.y = element_blank(),
        axis.text.x = element_text(size = rel(3)), 
        axis.title = element_blank(),
        axis.line.y = element_blank(),
        axis.ticks = element_blank(),
        axis.line.x = element_blank(),
        panel.grid = element_blank(),
        panel.grid.major.x = element_line(size = 2, linetype = "solid"),
        plot.background = element_rect(fill = '#f6f1eb', colour = "#f6f1eb"),
        plot.margin = margin(1, 2, 0, 2, "cm"),
        panel.background = element_rect(fill = '#e3dfda', colour = NA))

gif2 <- animate(
  plot_timeline +
    transition_states(date,
                      transition_length = 1,
                      state_length = 0,
                      wrap = F),
  width =1800, height = 130, nframes = nframesAnim, duration = durationAnim, end_pause = 10, rewind = F
)
gif2


```

## Results

Comparing models based on AIC is a robust approach to comparing the different model structures. It has been shown to be an appropriate means of model comparison for models fit with `gam()`, but has not been similarly confirmed for models fit with `gamm()`. While we use this approach here, results should be taken with a grain of salt. For example, even though visual inspection of predictions of models GS and GI seem to show evidence of improvement over model G, Table \@ref(tab:AICkable) does not provides evidence for including among-group functional variability. In @pedersen2019hierarchical, they caution against selecting models based purely on AIC. Instead, model selection should be based on expert subject knowledge about the system, computational time, and most importantly, the inferential goals of the study. 

```{r AIC_table, eval = T, echo=FALSE,  fig.width=4, fig.height=6, message=FALSE, warning=FALSE, cache=TRUE}
AIC_table <- AIC(gamm_modG_ARMA$lme,
                 gamm_modGS$lme,
                 gamm_modGI$lme)%>%
  tibble::rownames_to_column(var= "Model")%>%
  # mutate(data_source = rep(c("CO2","bird_data"), each =5))%>%
  # group_by(data_source)%>%
  mutate(deltaAIC = AIC - min(AIC))%>%
  # ungroup()%>%
  # dplyr::select(-data_source)%>%
  mutate_at(.vars = vars(df,AIC, deltaAIC),
            .funs = funs(round,.args = list(digits=0)))
```

```{r AICkable, eval = T, echo=FALSE,  fig.width=4, fig.height=6, message=FALSE, warning=FALSE, cache=TRUE, purl=FALSE}
kable(AIC_table, 
      format =table_out_format,
      caption="AIC table comparing model fits",
      booktabs = TRUE)%>%
  kable_styling(full_width = FALSE)
```

 To evaluate how well each model fits the data, we calculated the total deviance of the in-sample data. The deviance is equal to two times the sum of the difference between the log-likelihood of the in-sample data (as predicted by each model) and a saturated model that has one predictor for each data point, all multiplied by the scale parameter for the family of interest. It can be interpreted similarly to the residual sum of squares for a simple linear regression (Wood, 2017a, p. 109).

Table \@ref(tab:deviance-kable) shows that both models GS and GI are better at predicting in-sample fits for all trail subsections in this analysis. While this provides additional evidence for including inter-group variability in our model, it does contradict our AIC findings. 

```{r deviance, eval = T, echo=FALSE, message=FALSE}
# we need to compare how well this model fits with a null model. here we'll use an
# intercept-only model
gam_mod0 <- gam(max.camera ~ s(subsectionF,bs="re"),
                     data=allTrail,
                     knots = list(day =c(0, 365)),
                     family = poisson, 
                     method = "REML")

save(gam_mod0, file=here("output/models/allT_subsection_gamm_mod0.rda"),
     compress='xz')
#Correlations between fitted and observed values for all subsections:
#\n is in variable titles to add a line break in the printed table.
mod0.pred <- (as_tibble(predict(gam_mod0, allTrail, type="response"))) 
colnames(mod0.pred) <- c("mod0")

modG.pred <- as_tibble((predict(gamm_modG_ARMA$gam, 
                          allTrail, 
                          se.fit = F, 
                          type = "response"))) %>% 
    rename(modG = value)
modGS.pred <- as_tibble(predict(gamm_modGS$gam, 
                           allTrail, 
                          se.fit = F, 
                            type = "response")) %>%
    rename(modGS = value)
modGI.pred <- as_tibble(predict(gamm_modGI$gam, 
                           allTrail, 
                          se.fit = F, 
                            type = "response")) %>%
    rename(modGI = value)



test_summary =  bind_cols(allTrail, mod0.pred,
                          modG.pred, modGS.pred, 
                          modGI.pred) %>% 
  tidyr::drop_na(daily_aqi_value) %>% 
  group_by(subsectionF)%>%
  summarise(
    `Intercept only` = format(get_deviance(gam_mod0, mod0, max.camera), 
                              scientific = FALSE, 
                              digits=3),
    
    `Model G` = format(get_deviance(gamm_modG_ARMA$gam, modG, max.camera), 
                       scientific = FALSE, 
                       digits=3),
    `Model GS` = format(get_deviance(gamm_modGS_AR1$gam, modGS, max.camera), 
                       scientific = FALSE, 
                       digits=3),
    `Model GI` = format(get_deviance(gamm_modGI_AR1$gam, modGI, max.camera), 
                       scientific = FALSE, 
                       digits=3)
    )
```

```{r deviance-kable, eval= T, echo=FALSE, message=FALSE}
test_summary%>%
  #need to specify this to ensure that species names are italized in the table
  # mutate(taxon = cell_spec(taxon, 
  #                          italic = c(TRUE,FALSE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE)))%>%
  # #Capitilizing taxon in the table names
  # rename(Taxon = taxon)
kable(test_summary, 
      format = table_out_format, 
      caption="Predictive ability for models \\emph{G}, \\emph{GS}, and \\emph{GI} applied to the Bridger Mountain trail use dataset. Deviance values represent the total deviance of model predictions from observations. Intercept only results are for a null model with only subsection-level random effect intercepts included.",
      booktabs = TRUE,
      escape = FALSE)%>%
  add_header_above(c(" " = 1, "Total deviance" = 3),
                   escape = FALSE)%>%
  kable_styling(full_width = FALSE) %>%
  row_spec(2:3,italic = FALSE) %>%
  row_spec(2:3, italic = FALSE)
  
```

## Conclusions

The GAM framework and its extensions that allow for modelling non-linear and linear relationships between response variables and predictors with random effects and a way to account for temporal autocorrelation is a valuable tool for a statistical analysis of trail use in the Bridger Mountains. Limitations of this model includes not being able to incorporate both spatial and temporal autocorrelation without some heavy lifting required. It's not clear how to model nested random effects of trail and trail subsections in this model. Section \@ref(Spatial) provides a look at an alternative model that allows for spatial correlation to be incorporated instead of temporal.

While the GAM framework for modelling is a powerful tool, it also requires a lot of modeling specification decisions. In this report we have discussed different options for model type that allows for different ways to provide a global smoother and inter-trail variation (models G, GS, and GI), the choice of basis functions and number of knots, differing ways to account for temporal correlation, and what/how many predictor variables to include. Model complexity could increase if interaction terms were to be included as well. Another complication is that while tools for diagnotics and model comparison are well developed for models fit with the `gam()` function, when we fit with the `gamm()` function (as we do in this model with our timeseries data) extra care must be taken as not all tools are appropriate in this case. Packages such as the **gratia** package which provides visulizing and diagnostic functions for GAMs is still adding functionality and will likely provide additional tools for future analyses. Even with all of this considered, this modelling framework has been shown to be a promising way to analyse recreational trail use and contains a lot of flexibility while being able to not only provide predictions at new trails/times of year but also valuable insight into trends for each predictor variable. The predictive abilities of these models will increase as additional data is made available.  

With this in mind, we provide the following recommendations for future observations periods and analyses.

1. It is better to have cameras deployed for longer periods of times. Year-round data for even a subset of trails will help improve predictions across all trails. 
2. Subsections within a trail seem to capture similar data. Cameras spread across more trails may provide more information than multiple camera counters deployed along a single trail. 
3. Multiple years of data would provide valuable information about annual trends and be helpful in forecasting trail use into the future. 
4. If spatiotemporal correlation structure is available for future analysis then it would be helpful to consider the spatial network node/edge designations in tandem with camera placement. 
<!-- -limitations of model - lack of data for all days/year - lack of multi-year data - not sure how to do nested spatial random effect for trail and subsection - how do alt trail predictions go? - colinearity/concavity of covariates. difficult to know when interaction effects are needed. - -->
<!-- -recommendations for future use - better to have cameras on different trails for long time - subsections within a trail seem to capture similar data - multiple years of observations very helpful for forecasting - spatial network approach might be good for informing trail/subsection network design, but still hard to combine with temporal AC -->
